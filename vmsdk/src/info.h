
/*
 * Copyright (c) 2025, valkey-search contributors
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in the
 *     documentation and/or other materials provided with the distribution.
 *   * Neither the name of Redis nor the names of its contributors may be used
 *     to endorse or promote products derived from this software without
 *     specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef VMSDK_SRC_UTILS_INFO_H_
#define VMSDK_SRC_UTILS_INFO_H_

#include <atomic>
#include <optional>

#include "absl/strings/string_view.h"
#include "vmsdk/src/valkey_module_api/valkey_module.h"

/*

Info Metrics

All of the fields that are reported by the "INFO" command are automatically generated by the 
machinery in the "vmsdk::info_field" namespace.

To create an info field you instantiate one of the objects defined in this file and then
increment it at appropriate places in your code. The infrastructure handles the rest of the work
for you automatically.

The Valkey core invokes the info machinery in two different situations. In the first situation you see it
as part of the INFO command. This invocation happens on the Main Thread.

If a crash occurs, then the info machinery is invoked as part of the crash dump procedure.
This invocation can happen in any thread context at any time -- meaning that info fields that
depend on locking a mutex, allocating memory or examining a complex data structure that might be in
the process of being mutated must not be part of a crash dump. The designation of crash-safe
info fields is done through a flag. The absence of that flag in the definition of the field
will mean that it won't be part of a crash dump. Some of the utility classes for info fields
(AppCounter and DevCounter) are by nature crash-safe and they set the crash-safe flag for you.

Stylistically, the expectation is that application code should be able to use the classes defined in this file
for all of their info fields.

The infrastructure requires that all info fields be designated as either Application or Developer fields.
The primary difference is that the OSS Community pledges to maintain Application info fields compatibly between
releases. Whereas Developer info fields explicitly do not have this pledge and are subject to change from release
to release without notice. Best practices for application developers is to only rely on Application info fields.
There is a CONFIG variable in the infrastructure to enable/disable the visibility of Developer info fields.
When this is at it's default setting, there is no external visibility for Developer info fields. Thus applications
which are developed around unmodified OSS code (or a pre-built binary) can safely use all of the info fields that
appear.

*/

namespace vmsdk {
namespace info_field {

//
// Validate configuration, Called on load to avoid difficult to diagnose asserts on module load
//
// false-> failure with reason written to the log.
//
bool Validate(RedisModuleCtx *ctx);

//
// Info Function Interface.
//
void DoSection(RedisModuleInfoCtx *ctx, absl::string_view section, int for_crash_report);
void DoRemainingSections(RedisModuleInfoCtx *ctx, int for_crash_report);

enum Flags {
    //
    // All Info fields must have exactly one of kApplication or kDeveloper specified or 
    // you'll get an assert on Module load.
    //
    kApplication = 1,    // Cross-release maintained
    kDeveloper = 2,      // For Developers, not cross-release maintained
    //
    // By default, fields aren't considered crash-safe, set this flag to indicate that they are
    //
    kCrashSafe = 4,     // This field is Crash Safe

    //
    // For Numeric
    //
    kSIUnits = 8,
}; 

class Base {
protected:
    std::string section_;
    std::string name_;
    Flags flags_;

    virtual ~Base();
    Base(absl::string_view section, absl::string_view name, Flags flags);
    Base(const Base&) = delete;
    Base(const Base&&) = delete;

    friend struct NumericBuilder;
    friend struct StringBuilder;
 public:
    const std::string& GetSection() const { return section_; }
    const std::string& GetName() const { return name_; }
    Flags GetFlags() const { return flags_; }
    virtual void Dump(RedisModuleInfoCtx *ctx) const = 0;
    virtual bool IsVisible() const = 0;
};

//
// Builder for Numeric when the defaults aren't desirable.
//
struct NumericBuilder {
    // Mark this Application Visible
    NumericBuilder() = default;
    NumericBuilder& AppVisible() {
        flags_ = Flags((flags_ & ~(Flags::kApplication | Flags::kDeveloper)) | Flags::kApplication);
        return *this;
    }
    // Mark as Developer Visible
    NumericBuilder& DevVisible() {
        flags_ = Flags((flags_ & ~(Flags::kApplication | Flags::kDeveloper)) | Flags::kDeveloper);
        return *this;
    }
    // Dump in Human Readable SI Units, typically for bytes 
    NumericBuilder& SIUnits() {
        flags_ = Flags(flags_ | Flags::kSIUnits);
        assert(flags_ & Flags::kSIUnits);
        return *this;
    }
    // If visible optionally. Note: this field will not be visible in crash dumps
    NumericBuilder& VisibleIf(std::function<bool ()> visible_func) {
        visible_func_ = visible_func;
        flags_ = Flags(flags_ & ~Flags::kCrashSafe);
        return *this;
    }
    // Computed Value. Note this field will not be visible in crash dumps
    NumericBuilder& Computed(std::function<long long()> compute_func) {
        compute_func_ = compute_func;
        flags_ = Flags(flags_ & ~Flags::kCrashSafe);
        return *this;
    }
    //
    // DANGER: Overrides the default assumption that callback functions aren't crash safe.
    // Only use this function if you're certain that your callback doesn't access any locks
    // OR never allocations any memory
    //
    NumericBuilder& CrashSafe() {
        flags_ = Flags(flags_ | Flags::kCrashSafe);
        return *this;
    }
  private:
    friend class Numeric;
    Flags flags_{Flags::kCrashSafe};
    std::optional<std::function<bool ()>> visible_func_;
    std::optional<std::function<long long ()>>  compute_func_;
};

//
// All numeric fields
//
class Numeric : private Base {
  public:
    long long Increment(long long amount = 1) {
        return value_.fetch_add(amount, std::memory_order_relaxed);
    }
    long long Decrement(long long amount = 1) {
        return value_.fetch_sub(amount, std::memory_order_relaxed);
    }
    long long Set(long long value = 0) {
        return value_.exchange(value, std::memory_order_relaxed);
    }
    long long Get() const { return value_.load(std::memory_order_relaxed); }
    Numeric(absl::string_view section, absl::string_view name, NumericBuilder builder = NumericBuilder());
  private:
    friend struct NumericBuilder;
    void Dump(RedisModuleInfoCtx *ctx) const final;
    bool IsVisible() const final;
    std::atomic<long long> value_{0};
    std::optional<std::function<bool ()>> visible_func_;
    std::optional<std::function<long long ()>>  compute_func_;
};

//
// Builder for all String Valued Fields
//
struct StringBuilder {
    StringBuilder& AppVisible() {
        flags_ = Flags((flags_ & (Flags::kApplication | Flags::kDeveloper)) | Flags::kApplication);
        return *this;
    }
    // Mark as Developer Visible
    StringBuilder& DevVisible() {
        flags_ = Flags((flags_ & (Flags::kApplication | Flags::kDeveloper)) | Flags::kDeveloper);
        return *this;
    }
    // If visible optionally. Note: this field will not be visible in crash dumps
    StringBuilder& VisibleIf(std::function<bool ()> visible_func) {
        visible_func_ = visible_func;
        flags_ = Flags(flags_ & ~Flags::kCrashSafe);
        return *this;
    }
    // Computed Value. Note this field will not be visible in crash dumps
    StringBuilder& Computed(std::function<std::string ()> compute_func) {
        compute_string_func_ = compute_func;
        flags_ = Flags(flags_ & ~Flags::kCrashSafe);
        return *this;
    }
    // Computed Value. This function is assumed to be crash safe.
    StringBuilder& Computed(std::function<const char * ()> compute_func) {
        compute_char_func_ = compute_func;
        return *this;
    }
    //
    // DANGER: Overrides the default assumption that callback functions aren't crash safe.
    // Only use this function if you're certain that your callback doesn't access any locks
    // OR never allocations any memory
    //
    StringBuilder& CrashSafe() {
        flags_ = Flags(flags_ | Flags::kCrashSafe);
        return *this;
    }
  private:
    friend class String;
    Flags flags_{kDeveloper};
    std::optional<std::function<bool ()>> visible_func_;
    std::optional<std::function<const char *()>>  compute_char_func_;
    std::optional<std::function<std::string ()>>  compute_string_func_;
};

//
// All String Valued Fields
//
class String : private Base {
 public:
    String(absl::string_view section, absl::string_view name, StringBuilder builder);
  private:
    friend struct StringBuilder;
    void Dump(RedisModuleInfoCtx *ctx) const final;
    bool IsVisible() const final;
    std::optional<std::function<bool ()>> visible_func_;
    std::optional<std::function<const char *()>>  compute_char_func_;
    std::optional<std::function<std::string ()>>  compute_string_func_;
};

} // namespace info_field
} // namespace vmsdk

#endif